## -*- texinfo -*-
## @deftypefn  {Function File} {[@var{t}, @var{f}, @var{d}, @var{l}, @var{ns}] =} read_qsd (@var{filename})
##
## Reads a QSD file generated by Q-Sense's QSoft 401 software and returns time,
## frequency, damping, array length and number of sensors for the fundamental mode 
## and overtones.
##
## @var{t}: time array, in second, as many lines as timesteps, as many columns as overtones x sensors
##
## @var{f}: frequency array, in Hz, as many lines as timesteps, as many columns as overtones x sensors
##
## @var{d}: damping array, unitless (1/Q), as many lines as timesteps, as many columns as overtones x sensors
##
## @var{l}: dataset length, as many items as overtones x sensors, helps removing trailing 0s when assembling the measurement matrices @var{t}, @var{f} and @var{d}
##
## @var{ns}: number of sensors, currently tested with 1 and 4 QCM-D instruments
## @end deftypefn

function [tim,fre,dis,len,ns]=read_qsd(filename)
  f=fopen(filename);
  d=fread(f,"uint8");
  nmodes=strfind(char(d),"XtalDriveTimeFloat");
  pointer=nmodes(end)+30;
  nsensors=d(pointer);      % 1 or 4 depending on single or quad QSense system
  ns=nsensors;
  if ((nsensors!=1) && (nsensors!=4))
     error("Invalid number of sensors (should be 1 or 4), aborting\n");
  end
  pointer=pointer+4;
  n=d(pointer)+d(pointer+1)*256+d(pointer+2)*256*256+d(pointer+3)*256*256*256;
  len=n;
  pointer=pointer+4;        % skip length information
% 0000e4070100 04 000000 f6040000 07000000070000000700000007000000 ee0701 00090000000208000000000000 f704000002000000000000000100000000000000f6040000 0b 00f7040000b9
% 0000e4070100 01 000000 01260000 04000000                         ee0701 00090000000208000000000000 022600000200000000000000010000000000000001260000 0b 00022600001c
% 0000e4070100 01 000000 8d580000 07000000                         ee0701 00090000000208000000000000 8e580000                01000000000000008e580000 0b 008e5800001a
%              ns          len                                     ^^                                ^^
  pointer=pointer+(4*nsensors);  
  if (d(pointer) != 0xee)
     error("Invalid value: != 0xee\n");
  end
  pointer=pointer+16;  
  newn=d(pointer)+d(pointer+1)*256+d(pointer+2)*256*256+d(pointer+3)*256*256*256;
  if (newn!=len+1) 
     error("Invalid size repetition\n");
  end
  pointer=pointer+4;    % skip size repetition 
  if (d(pointer)==2)    % added to validate BSA dataset
      pointer=pointer+8;
  end
  if (d(pointer) != 0x01)
     error("Invalid value: != 0x01\n");
  end
  pointer=pointer+12;
  if (d(pointer) != 0x0b)
     error("Invalid value: != 0x0b\n");
  end
  pointer=pointer+6;               % align with time information
  %%%%%%%%%%%%%%%%% first mode
  val=typecast(uint8([d(pointer:pointer+n*8-1+8*1)]),"double");
  tim=(val-val(1))*86400;                             % seconds
  pointer=pointer+n*8-1+8*1+3;
  n=d(pointer)+d(pointer+1)*256+d(pointer+2)*256*256+d(pointer+3)*256*256*256;
  pointer=pointer+4;
  val=typecast(uint8([d(pointer:pointer+n*8-1)]),"double");
  fre=val;
  pointer=pointer+n*8-1;
  pointer=pointer+7;
  val=typecast(uint8([d(pointer:pointer+n*8-1)]),"double");
  dis=val;
  pointer=pointer+n*8-1;
  m=2;
  while (1)         % TODO: replace this infinite loop + break with do ... while
  %%%%%%%%%%%%%%%%% overtones
    pointer=pointer+9;
    n=d(pointer)+d(pointer+1)*256+d(pointer+2)*256*256+d(pointer+3)*256*256*256;
    if (n==0)  % the end, last overtone read
       nsensors=nsensors-1;
       pointer=pointer+40;
       n=d(pointer)+d(pointer+1)*256+d(pointer+2)*256*256+d(pointer+3)*256*256*256;
       if (nsensors==0)
          break
       end
    end
    pointer=pointer-2;
    pointer=pointer+3*8;
    val=typecast(uint8([d(pointer:pointer+n*8-1)]),"double");
    if (length(val)<=length(tim))
       eval(["tim(1:length(val),",num2str(m),")=(val-val(1))*86400;"]); % subset
    else
       eval(["tim(:,",num2str(m),")=(val-val(1))*86400;"]); % seconds
    end
    pointer=pointer+n*8-1;
    pointer=pointer+3;
    n=d(pointer)+d(pointer+1)*256+d(pointer+2)*256*256+d(pointer+3)*256*256*256;
    len(m)=n;
    pointer=pointer+4;
    val=typecast(uint8([d(pointer:pointer+n*8-1)]),"double");
    if (length(val)<=length(fre))
       eval(["fre(1:length(val),",num2str(m),")=val;"]); % subset
    else
       eval(["fre(:,",num2str(m),")=val;"]); % seconds
    end
    pointer=pointer+n*8-1;
    pointer=pointer+7;
    val=typecast(uint8([d(pointer:pointer+n*8-1)]),"double");
    if (length(val)<=length(dis))
       eval(["dis(1:length(val),",num2str(m),")=val;"]); % subset
    else
       eval(["dis(:,",num2str(m),")=val;"]); % seconds
    end
    pointer=pointer+n*8-1;
    m=m+1;
  end
end 
